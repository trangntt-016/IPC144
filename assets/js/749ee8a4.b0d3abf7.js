"use strict";(self.webpackChunkipc144=self.webpackChunkipc144||[]).push([[393],{3905:function(t,e,n){n.d(e,{Zo:function(){return d},kt:function(){return k}});var a=n(7294);function r(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function l(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function i(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?l(Object(n),!0).forEach((function(e){r(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function o(t,e){if(null==t)return{};var n,a,r=function(t,e){if(null==t)return{};var n,a,r={},l=Object.keys(t);for(a=0;a<l.length;a++)n=l[a],e.indexOf(n)>=0||(r[n]=t[n]);return r}(t,e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(t);for(a=0;a<l.length;a++)n=l[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(r[n]=t[n])}return r}var s=a.createContext({}),c=function(t){var e=a.useContext(s),n=e;return t&&(n="function"==typeof t?t(e):i(i({},e),t)),n},d=function(t){var e=c(t.components);return a.createElement(s.Provider,{value:e},t.children)},u={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},p=a.forwardRef((function(t,e){var n=t.components,r=t.mdxType,l=t.originalType,s=t.parentName,d=o(t,["components","mdxType","originalType","parentName"]),p=c(n),k=r,h=p["".concat(s,".").concat(k)]||p[k]||u[k]||l;return n?a.createElement(h,i(i({ref:e},d),{},{components:n})):a.createElement(h,i({ref:e},d))}));function k(t,e){var n=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var l=n.length,i=new Array(l);i[0]=p;var o={};for(var s in e)hasOwnProperty.call(e,s)&&(o[s]=e[s]);o.originalType=t,o.mdxType="string"==typeof t?t:r,i[1]=o;for(var c=2;c<l;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},4336:function(t,e,n){n.r(e),n.d(e,{frontMatter:function(){return o},contentTitle:function(){return s},metadata:function(){return c},toc:function(){return d},default:function(){return p}});var a=n(7462),r=n(3366),l=(n(7294),n(3905)),i=["components"],o={sidebar_position:1},s="Arrays",c={unversionedId:"C-Data-Structures/arrays",id:"C-Data-Structures/arrays",isDocsHomePage:!1,title:"Arrays",description:"Learning Outcomes",source:"@site/docs/C-Data-Structures/arrays.md",sourceDirName:"C-Data-Structures",slug:"/C-Data-Structures/arrays",permalink:"/C-Data-Structures/arrays",editUrl:"https://github.com/Seneca-ICTOER/IPC144/tree/main/docs/C-Data-Structures/arrays.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"courseNotesSidebar",previous:{title:"Testing & Debugging",permalink:"/B-Computations/testing-and-debugging"},next:{title:"Structures",permalink:"/C-Data-Structures/structures"}},d=[{value:"Learning Outcomes",id:"learning-outcomes",children:[],level:2},{value:"Introduction",id:"introduction",children:[],level:2},{value:"Definition",id:"definition",children:[],level:2},{value:"Elements",id:"elements",children:[{value:"Check Array Bounds",id:"check-array-bounds",children:[],level:3}],level:2},{value:"Initialization",id:"initialization",children:[],level:2},{value:"Parallel Arrays",id:"parallel-arrays",children:[],level:2},{value:"Character Strings",id:"character-strings",children:[{value:"Introduction",id:"introduction-1",children:[],level:3},{value:"Syntax",id:"syntax",children:[],level:3}],level:2}],u={toc:d};function p(t){var e=t.components,n=(0,r.Z)(t,i);return(0,l.kt)("wrapper",(0,a.Z)({},u,n,{components:e,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"arrays"},"Arrays"),(0,l.kt)("h2",{id:"learning-outcomes"},"Learning Outcomes"),(0,l.kt)("p",null,"After reading this section, you will be able to:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Design data collections using arrays to manage information efficiently"),(0,l.kt)("li",{parentName:"ul"},"Introduce character strings as terminated collections of byte information")),(0,l.kt)("h2",{id:"introduction"},"Introduction"),(0,l.kt)("p",null,"Programs can process extremely large amounts of data much faster than well-established manual techniques.  Whether this processing is efficient or not depends in large part on how that data is organized.  For example, large collections of data can be organized in structures if each variable shares the same type with all other variables and the variables are stored contiguously in memory.  Not only can structured data be processed efficiently but the programming of tasks performed on structured data can be simplified considerably.  Instead of coding a separate instruction for each variable, we code the instruction that is common to all variables and apply that instruction in an iteration across the data structure."),(0,l.kt)("p",null,(0,l.kt)("img",{parentName:"p",src:"https://ict.senecacollege.ca//~ipc144/pages/images/arrays.png",alt:null})),(0,l.kt)("p",null,"The simplest data structure in the C language is a list of variables of the same type.  We call such a list an array and the variables in that array its elements.  We refer to any element by its index. "),(0,l.kt)("p",null,"This chapter introduces the syntax for defining arrays, initializing them and accessing their elements directly.  The chapter also demonstrates how to construct a table of values using the concept of a parallel array.  This chapter concludes by introducing character strings as arrays with a special terminator."),(0,l.kt)("h2",{id:"definition"},"Definition"),(0,l.kt)("p",null,"An array is a data structure consisting of an ordered set of elements of common type that are stored contiguously in memory.  Contiguous storage is storage without any gaps.  An array definition takes the form"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("inlineCode",{parentName:"strong"},"type identifier [ size ];"))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("em",{parentName:"strong"},"type"))," is the type of each element, ",(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("em",{parentName:"strong"},"identifier"))," is the array's name, the brackets ",(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("em",{parentName:"strong"},"[ ]"))," identify the data structure as an array and size specifies the number of elements in the array. "),(0,l.kt)("p",null,"For example, to define an array of 8 grades, we write:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"int grade[8];\n")),(0,l.kt)("p",null,"This statement allocates contiguous storage in RAM for an array named grade that consists of 8 int elements."),(0,l.kt)("table",{border:"0"},(0,l.kt)("td",{align:"center",colspan:"32"},"int",(0,l.kt)("br",null),"grade[8]"),(0,l.kt)("tr",null,(0,l.kt)("td",{align:"center",colspan:"4"},"4 bytes"),(0,l.kt)("td",{align:"center",colspan:"4"},"4 bytes"),(0,l.kt)("td",{align:"center",colspan:"4"},"4 bytes"),(0,l.kt)("td",{align:"center",colspan:"4"},"4 bytes"),(0,l.kt)("td",{align:"center",colspan:"4"},"4 bytes"),(0,l.kt)("td",{align:"center",colspan:"4"},"4 bytes"),(0,l.kt)("td",{align:"center",colspan:"4"},"4 bytes"),(0,l.kt)("td",{align:"center",colspan:"4"},"4 bytes")),(0,l.kt)("tr",null,(0,l.kt)("td",{align:"center"},"\xa0"),(0,l.kt)("td",{align:"center"},"\xa0"),(0,l.kt)("td",{align:"center"},"\xa0"),(0,l.kt)("td",{align:"center"},"\xa0"),(0,l.kt)("td",{align:"center"},"\xa0"),(0,l.kt)("td",{align:"center"},"\xa0"),(0,l.kt)("td",{align:"center"},"\xa0"),(0,l.kt)("td",{align:"center"},"\xa0"),(0,l.kt)("td",{align:"center"},"\xa0"),(0,l.kt)("td",{align:"center"},"\xa0"),(0,l.kt)("td",{align:"center"},"\xa0"),(0,l.kt)("td",{align:"center"},"\xa0"),(0,l.kt)("td",{align:"center"},"\xa0"),(0,l.kt)("td",{align:"center"},"\xa0"),(0,l.kt)("td",{align:"center"},"\xa0"),(0,l.kt)("td",{align:"center"},"\xa0"),(0,l.kt)("td",{align:"center"},"\xa0"),(0,l.kt)("td",{align:"center"},"\xa0"),(0,l.kt)("td",{align:"center"},"\xa0"),(0,l.kt)("td",{align:"center"},"\xa0"),(0,l.kt)("td",{align:"center"},"\xa0"),(0,l.kt)("td",{align:"center"},"\xa0"),(0,l.kt)("td",{align:"center"},"\xa0"),(0,l.kt)("td",{align:"center"},"\xa0"),(0,l.kt)("td",{align:"center"},"\xa0"),(0,l.kt)("td",{align:"center"},"\xa0"),(0,l.kt)("td",{align:"center"},"\xa0"),(0,l.kt)("td",{align:"center"},"\xa0"),(0,l.kt)("td",{align:"center"},"\xa0"),(0,l.kt)("td",{align:"center"},"\xa0"),(0,l.kt)("td",{align:"center"},"\xa0"),(0,l.kt)("td",{align:"center"},"\xa0")),(0,l.kt)("tr",null,(0,l.kt)("td",{align:"center",colspan:"4"},"0"),(0,l.kt)("td",{align:"center",colspan:"4"},"1"),(0,l.kt)("td",{align:"center",colspan:"4"},"2"),(0,l.kt)("td",{align:"center",colspan:"4"},"3"),(0,l.kt)("td",{align:"center",colspan:"4"},"4"),(0,l.kt)("td",{align:"center",colspan:"4"},"5"),(0,l.kt)("td",{align:"center",colspan:"4"},"6"),(0,l.kt)("td",{align:"center",colspan:"4"},"7"))),(0,l.kt)("p",null,"We can specify the size of the array using ",(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("inlineCode",{parentName:"strong"},"#define"))," or ",(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("inlineCode",{parentName:"strong"},"const int")),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},'#define NGRADES 8  // or const int NGRADES = 8;\n\nint grade[NGRADES];\n\n// ... record the grades\n\nprintf("Your last grade was %d\\n", grade[NGRADES - 1]);\nprintf("Your second last grade was %d\\n", grade[NGRADES - 2]); \n\n')),(0,l.kt)("p",null,"This coding style facilitates modifiability.  If we change the size, we need to do so in only one place."),(0,l.kt)("h2",{id:"elements"},"Elements"),(0,l.kt)("p",null,"Each element has a unique index and holds a single value.  Index numbering starts at 0 and extends to one less than the the number of elements in the array.  To refer to a specific element, we write the array name followed by bracket notation around the element's index."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("inlineCode",{parentName:"strong"},"identifier[index]"))),(0,l.kt)("p",null,"For example, to access the first element of grade, we write:"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("inlineCode",{parentName:"strong"},"grade[0]"))),(0,l.kt)("p",null,"To display all elements of grade, we iterate:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},'for (i = 0; i < NGRADES; i++) {\n    printf("%d" , grade[i]);\n}\n')),(0,l.kt)("h3",{id:"check-array-bounds"},"Check Array Bounds"),(0,l.kt)("p",null,"C compilers do not introduce code that checks whether an element's index is within the bounds of its array.  It is our responsibility as programmers to ensure that our code does not include index values that point to elements outside the memory allocated for an array."),(0,l.kt)("h2",{id:"initialization"},"Initialization"),(0,l.kt)("p",null,"We can initialize an array when we define it in the same way that we initialize variables.  We suffix the declaration with an assignment operator followed by the set of initial values.  We enclose the values in the set within a pair of braces and separate them with commas.  Initialization takes the form:"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("inlineCode",{parentName:"strong"},"type identifier[ size ] = { value, ... , value };"))),(0,l.kt)("p",null,"For example, to initialize grade, we write:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"int grade[NGRADES] = {10,9,10,8,7,9,8,10};\n")),(0,l.kt)("table",{border:"0"},(0,l.kt)("tr",null,(0,l.kt)("td",null,"Array Identifier"),(0,l.kt)("td",{align:"center",colspan:"8"},(0,l.kt)("b",null,"int"),(0,l.kt)("br",null),(0,l.kt)("b",null,"grade"))),(0,l.kt)("tr",null,(0,l.kt)("td",null,"Value"),(0,l.kt)("td",{align:"center"},"10"),(0,l.kt)("td",{align:"center"},"9"),(0,l.kt)("td",{align:"center"},"10"),(0,l.kt)("td",{align:"center"},"8"),(0,l.kt)("td",{align:"center"},"7"),(0,l.kt)("td",{align:"center"},"9"),(0,l.kt)("td",{align:"center"},"8"),(0,l.kt)("td",{align:"center"},"10")),(0,l.kt)("tr",null,(0,l.kt)("td",null,"Element Index"),(0,l.kt)("td",{align:"center"},"0"),(0,l.kt)("td",{align:"center"},"1"),(0,l.kt)("td",{align:"center"},"2"),(0,l.kt)("td",{align:"center"},"3"),(0,l.kt)("td",{align:"center"},"4"),(0,l.kt)("td",{align:"center"},"5"),(0,l.kt)("td",{align:"center"},"6"),(0,l.kt)("td",{align:"center"},"7"))),(0,l.kt)("p",null,"If our initialization fills all elements in the array, C compilers infer the size of the array from the initization set and we do not need to specify the size between the brackets.  We may simply write:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"int grade[] = {10,9,10,8,7,9,8,10};\n")),(0,l.kt)("p",null,"If we specify fewer initial values than the size of the array, C compilers fill the uninitialized elements with zero values:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"int grade[NGRADES] = {0};\n")),(0,l.kt)("p",null,"This will initializes ",(0,l.kt)("u",null,"all")," 8 elements of ",(0,l.kt)("inlineCode",{parentName:"p"},"grade")," to zero. "),(0,l.kt)("p",null,"Specifying a size that is less than the number of initial values generates a syntax error."),(0,l.kt)("h2",{id:"parallel-arrays"},"Parallel Arrays"),(0,l.kt)("p",null,"A convenient way to store tabular information is through two parallel arrays.  One arrays holds the key, while the other hold values.  The arrays are parallel because the elements at the same index hold data that are related to the same entity. "),(0,l.kt)("p",null,"In the following example, ",(0,l.kt)("inlineCode",{parentName:"p"},"sku[i]")," holds the stock keeping unit (sku) for a product, while ",(0,l.kt)("inlineCode",{parentName:"p"},"price[i]")," holds its unit price. "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},'// Parallel Arrays\n// parallel.c\n\n#include <stdio.h>\n\nint main(void)\n{\n    int i;\n    int sku[]      = { 2156, 4633, 3122, 5611};\n    double price[] = { 2.34, 7.89, 6.56, 9.32};\n    const int n    = 4;\n    \n    printf("  SKU Price\\n");\n    for (i = 0; i < n; i++)\n        printf("%5d $%.2lf\\n", sku[i], price[i]); \n    \n    return 0;\n}\n')),(0,l.kt)("p",null,"Output of the above program:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"  SKU Price \n 2156 $2.34\n 4633 $7.89\n 3122 $6.56\n 5611 $9.32\n")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"sku[]")," array holds the key data, while the ",(0,l.kt)("inlineCode",{parentName:"p"},"price[]")," array holds the value data.  Note how the elements of parallel arrays with the same index make up the fields of a single record of information. "),(0,l.kt)("p",null,"Parallel arrays are simple to process.  For example, once we find the index of the element that matches the specified sku, we also have the index of the unit price for that element."),(0,l.kt)("h2",{id:"character-strings"},"Character Strings"),(0,l.kt)("p",null,"The topic of character strings is covered in depth in the chapter entitled ",(0,l.kt)("a",{parentName:"p",href:"/F-Refinements/character-strings"},"Character Strings"),".  The following section introduces this topic at a high level."),(0,l.kt)("h3",{id:"introduction-1"},"Introduction"),(0,l.kt)("p",null,"A ",(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("em",{parentName:"strong"},"string"))," is a ",(0,l.kt)("inlineCode",{parentName:"p"},"char")," array with a special property: a ",(0,l.kt)("strong",{parentName:"p"},"terminator element")," follows the last meaningful character in the string.  We refer to this terminator as the ",(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("em",{parentName:"strong"},"null terminator"))," and identify it by the escape sequence ",(0,l.kt)("inlineCode",{parentName:"p"},"'\\0'"),". "),(0,l.kt)("table",{border:"0"},(0,l.kt)("tr",null,(0,l.kt)("td",{align:"center",colspan:"18"},"char")),(0,l.kt)("tr",null,(0,l.kt)("td",null,"\xa0"),(0,l.kt)("td",null,"\xa0"),(0,l.kt)("td",null,"\xa0"),(0,l.kt)("td",null,"\xa0"),(0,l.kt)("td",null,"\xa0"),(0,l.kt)("td",null,"\xa0"),(0,l.kt)("td",null,"\xa0"),(0,l.kt)("td",null,"\xa0"),(0,l.kt)("td",null,"\xa0"),(0,l.kt)("td",null,"\xa0"),(0,l.kt)("td",null,"\xa0"),(0,l.kt)("td",null,"\xa0"),(0,l.kt)("td",null,"\xa0"),(0,l.kt)("td",null,"\xa0"),(0,l.kt)("td",null,"\xa0"),(0,l.kt)("td",null,"\xa0"),(0,l.kt)("td",null,"\xa0"),(0,l.kt)("td",null,(0,l.kt)("em",null,(0,l.kt)("b",null,"\\0"))))),(0,l.kt)("p",null,"The null terminator has the value 0 on any host platform (in its collating sequence).  All of its bits are 0's.  The null terminator occupies the first position in the ",(0,l.kt)("a",{parentName:"p",href:"/Resources-Appendices/ascii-collating-sequence"},"ASCII")," and ",(0,l.kt)("a",{parentName:"p",href:"/Resources-Appendices/ebcdic-collating-sequence"},"EBCDIC")," collating sequences. "),(0,l.kt)("p",null,"The value of the index identifying the null terminator element is the number of meaningful characters in the string. "),(0,l.kt)("table",{border:"0"},(0,l.kt)("tr",null,(0,l.kt)("td",{align:"center",colspan:"18"},(0,l.kt)("b",null,"char",(0,l.kt)("br",null),"name"))),(0,l.kt)("tr",null,(0,l.kt)("td",null,"0"),(0,l.kt)("td",null,"1"),(0,l.kt)("td",null,"2"),(0,l.kt)("td",null,"3"),(0,l.kt)("td",null,"4"),(0,l.kt)("td",null,"5"),(0,l.kt)("td",null,"6"),(0,l.kt)("td",null,"7"),(0,l.kt)("td",null,"8"),(0,l.kt)("td",null,"9"),(0,l.kt)("td",null,"10"),(0,l.kt)("td",null,"11"),(0,l.kt)("td",null,"12"),(0,l.kt)("td",null,"13"),(0,l.kt)("td",null,"14"),(0,l.kt)("td",null,"15"),(0,l.kt)("td",null,"16"),(0,l.kt)("td",null,(0,l.kt)("b",null,"17"))),(0,l.kt)("tr",null,(0,l.kt)("td",null,"M"),(0,l.kt)("td",null,"y"),(0,l.kt)("td",null,"\xa0"),(0,l.kt)("td",null,"n"),(0,l.kt)("td",null,"a"),(0,l.kt)("td",null,"m"),(0,l.kt)("td",null,"e"),(0,l.kt)("td",null,"\xa0"),(0,l.kt)("td",null,"i"),(0,l.kt)("td",null,"s"),(0,l.kt)("td",null,"\xa0"),(0,l.kt)("td",null,"A"),(0,l.kt)("td",null,"r"),(0,l.kt)("td",null,"n"),(0,l.kt)("td",null,"o"),(0,l.kt)("td",null,"l"),(0,l.kt)("td",null,"d"),(0,l.kt)("td",null,(0,l.kt)("em",null,(0,l.kt)("b",null,"\\0"))))),(0,l.kt)("p",null,"The number of memory locations occupied by a string is one more than the number of meaningful characters in the string."),(0,l.kt)("h3",{id:"syntax"},"Syntax"),(0,l.kt)("p",null,"We need to allocate memory for one additional byte to provide room for the null terminator:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},'const int NCHAR = 17;\nchar name[NCHAR + 1] = "My Name is Arnold";\n')),(0,l.kt)("p",null,"We use the ",(0,l.kt)("inlineCode",{parentName:"p"},'"%s"')," conversion specifier and the address of the start of the character string to send its contents to standard output:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},'printf("%s", name);\n')),(0,l.kt)("p",null,"Formatting and handling syntax is covered later."))}p.isMDXComponent=!0}}]);