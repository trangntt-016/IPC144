"use strict";(self.webpackChunkipc144=self.webpackChunkipc144||[]).push([[499],{3905:function(t,e,n){n.d(e,{Zo:function(){return d},kt:function(){return u}});var a=n(7294);function r(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function i(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function l(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?i(Object(n),!0).forEach((function(e){r(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function o(t,e){if(null==t)return{};var n,a,r=function(t,e){if(null==t)return{};var n,a,r={},i=Object.keys(t);for(a=0;a<i.length;a++)n=i[a],e.indexOf(n)>=0||(r[n]=t[n]);return r}(t,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);for(a=0;a<i.length;a++)n=i[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(r[n]=t[n])}return r}var p=a.createContext({}),s=function(t){var e=a.useContext(p),n=e;return t&&(n="function"==typeof t?t(e):l(l({},e),t)),n},d=function(t){var e=s(t.components);return a.createElement(p.Provider,{value:e},t.children)},m={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},c=a.forwardRef((function(t,e){var n=t.components,r=t.mdxType,i=t.originalType,p=t.parentName,d=o(t,["components","mdxType","originalType","parentName"]),c=s(n),u=r,f=c["".concat(p,".").concat(u)]||c[u]||m[u]||i;return n?a.createElement(f,l(l({ref:e},d),{},{components:n})):a.createElement(f,l({ref:e},d))}));function u(t,e){var n=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var i=n.length,l=new Array(i);l[0]=c;var o={};for(var p in e)hasOwnProperty.call(e,p)&&(o[p]=e[p]);o.originalType=t,o.mdxType="string"==typeof t?t:r,l[1]=o;for(var s=2;s<i;s++)l[s]=n[s];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},4576:function(t,e,n){n.r(e),n.d(e,{frontMatter:function(){return o},contentTitle:function(){return p},metadata:function(){return s},toc:function(){return d},default:function(){return c}});var a=n(7462),r=n(3366),i=(n(7294),n(3905)),l=["components"],o={sidebar_position:3},p="More Input and Output",s={unversionedId:"F-Refinements/more-input-and-output",id:"F-Refinements/more-input-and-output",isDocsHomePage:!1,title:"More Input and Output",description:"Learning Outcomes",source:"@site/docs/F-Refinements/more-input-and-output.md",sourceDirName:"F-Refinements",slug:"/F-Refinements/more-input-and-output",permalink:"/F-Refinements/more-input-and-output",editUrl:"https://github.com/Seneca-ICTOER/IPC144/tree/main/docs/F-Refinements/more-input-and-output.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"courseNotesSidebar",previous:{title:"String Library",permalink:"/F-Refinements/string-library"},next:{title:"Pointers, Arrays and Structs",permalink:"/F-Refinements/pointers-arrays-and-structs"}},d=[{value:"Learning Outcomes",id:"learning-outcomes",children:[],level:2},{value:"Introduction",id:"introduction",children:[],level:2},{value:"Input",id:"input",children:[{value:"Formatted Input",id:"formatted-input",children:[],level:3},{value:"Conversion Control",id:"conversion-control",children:[],level:3},{value:"Unformatted Input",id:"unformatted-input",children:[],level:3}],level:2},{value:"Output",id:"output",children:[{value:"Formatted Output",id:"formatted-output",children:[],level:3},{value:"Conversion Specifiers",id:"conversion-specifiers",children:[],level:3},{value:"Conversion Control",id:"conversion-control-1",children:[],level:3}],level:2},{value:"Custom Input (Optional)",id:"custom-input-optional",children:[{value:"Mismatching Line Input",id:"mismatching-line-input",children:[],level:3},{value:"Insufficient Memory (Optional)",id:"insufficient-memory-optional",children:[],level:3},{value:"Safe Coding",id:"safe-coding",children:[],level:3}],level:2}],m={toc:d};function c(t){var e=t.components,n=(0,r.Z)(t,l);return(0,i.kt)("wrapper",(0,a.Z)({},m,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"more-input-and-output"},"More Input and Output"),(0,i.kt)("h2",{id:"learning-outcomes"},"Learning Outcomes"),(0,i.kt)("p",null,"After reading this section, you will be able to:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Implement algorithms using standard library procedures to incorporate existing technology"),(0,i.kt)("li",{parentName:"ul"},"Stream data using standard library functions to interact with users and access persistent text")),(0,i.kt)("h2",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,"The standard input and output library (stdio) that ships with C compilers provides comprehensive support for communicating with the user and with secondary storage.  This support includes numerical as well as character string processing under format control and optionally line by line processing without format control.  For platforms that don't support line by line input processing, we write our own custom procedures. "),(0,i.kt)("p",null,"This chapter reviews the conversion specifiers for formatted input and output along with the library functions for line by line input and output.  Specifiers not covered in previous chapters are included here.  This chapter concludes with two custom functions for input that safeguard line mismatching and memory overflow."),(0,i.kt)("h2",{id:"input"},"Input"),(0,i.kt)("p",null,"The stdio library functions for processing input are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"scanf()")," - input from standard input under format control"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"fscanf()")," - input from file under format control"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"getchar()")," - character by character input from standard input (see ",(0,i.kt)("a",{parentName:"li",href:"/D-Modularity/input-functions"},"Input Functions"),")"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"fgetc()")," - character by character input from file (see ",(0,i.kt)("a",{parentName:"li",href:"/D-Modularity/input-functions"},"Input Functions"),")"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"gets_s()")," - line by line input from standard input (not universally implemented)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"fgets()")," - line by line input from file")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"NOTE: Typically, ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"standard input"))," refers to the ",(0,i.kt)("strong",{parentName:"p"},"keyboard"),".")),(0,i.kt)("h3",{id:"formatted-input"},"Formatted Input"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"scanf(...)")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"fscanf(...)")," functions accept data from the standard input device or secondary storage respectively and store that data in memory at the address specified in their argument list.  Their prototypes are:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"int scanf(const char *format, address);\nint fscanf(FILE *, const char *format, address);\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"format")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"format")," receives a string literal that describes how to convert input text into data stored in memory.  Calls to these functions can take multiple arguments.  ",(0,i.kt)("inlineCode",{parentName:"p"},"format")," contains the conversion specifier(s) for translating the input characters.  Conversion specifiers begin with a ",(0,i.kt)("inlineCode",{parentName:"p"},"%")," symbol and identify the type of the destination variable.  The possible specifiers are listed below.  Other specifiers may be found ",(0,i.kt)("a",{parentName:"p",href:"http://www.cplusplus.com/reference/cstdio/scanf/"},"on the web"),"."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"left"},"Specifier"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Input Text is a"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Destination Type"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%c"),(0,i.kt)("td",{parentName:"tr",align:"left"},"character"),(0,i.kt)("td",{parentName:"tr",align:"left"},"char, char []")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%d"),(0,i.kt)("td",{parentName:"tr",align:"left"},"decimal"),(0,i.kt)("td",{parentName:"tr",align:"left"},"int, short, long, long long")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%i"),(0,i.kt)("td",{parentName:"tr",align:"left"},"integer"),(0,i.kt)("td",{parentName:"tr",align:"left"},"int, short, long, long long")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%o"),(0,i.kt)("td",{parentName:"tr",align:"left"},"unsigned octal"),(0,i.kt)("td",{parentName:"tr",align:"left"},"unsigned int, short, long, long long")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%x"),(0,i.kt)("td",{parentName:"tr",align:"left"},"unsigned hexadecimal"),(0,i.kt)("td",{parentName:"tr",align:"left"},"unsigned int, short, long, long long")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%u"),(0,i.kt)("td",{parentName:"tr",align:"left"},"unsigned decimal"),(0,i.kt)("td",{parentName:"tr",align:"left"},"unsigned int, short, long, long long")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%n"),(0,i.kt)("td",{parentName:"tr",align:"left"},"--"),(0,i.kt)("td",{parentName:"tr",align:"left"},"int, short, long, long long")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%f %e %g %a"),(0,i.kt)("td",{parentName:"tr",align:"left"},"floating-point"),(0,i.kt)("td",{parentName:"tr",align:"left"},"float, double, long double")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%s"),(0,i.kt)("td",{parentName:"tr",align:"left"},"character string"),(0,i.kt)("td",{parentName:"tr",align:"left"},"char []")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%","[ ]"," %[^ ]"),(0,i.kt)("td",{parentName:"tr",align:"left"},"character string"),(0,i.kt)("td",{parentName:"tr",align:"left"},"char []")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%p"),(0,i.kt)("td",{parentName:"tr",align:"left"},"address"),(0,i.kt)("td",{parentName:"tr",align:"left"},"any type")))),(0,i.kt)("blockquote",null,(0,i.kt)("u",null,"Remarks"),(0,i.kt)("br",null),"* `%n` does not read any characters but instead returns the number of characters processed. * `%f`, `%e`, `%g` and `%a` treat floating-point input identically. * *Size specifiers* also apply to `%i` , `%o`, `%x`, `%u` and `%n`, but are not listed here."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"address")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"address")," receives the address of the destination variable.  We specify a separate address argument for each conversion specifier in the format string. "),(0,i.kt)("h3",{id:"conversion-control"},"Conversion Control"),(0,i.kt)("p",null,"We may insert control characters between the ",(0,i.kt)("inlineCode",{parentName:"p"},"%")," and the conversion character.  The general form of a conversion specification is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"% * width size conversion_character\n")),(0,i.kt)("p",null,"The three control characters are:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"*","*","*")," - suppresses storage of the converted data (",(0,i.kt)("strong",{parentName:"li"},"discards")," it without storing it)"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("em",{parentName:"strong"},"width"))," - specifies the maximum number of characters to be interpreted"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("em",{parentName:"strong"},"size"))," - specifies the size of the storage type")),(0,i.kt)("blockquote",null,(0,i.kt)("u",null,"Exception"),(0,i.kt)("br",null),"A conversion specifier that includes an `*` does not have a corresponding address in the argument list.  This is an exception to the matching conversion-specifier/argument rule."),(0,i.kt)("p",null,"The size specifiers covered in this course are listed below.  Others may be found ",(0,i.kt)("a",{parentName:"p",href:"http://www.cplusplus.com/reference/cstdio/scanf/"},"on the web"),"."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"left"},"Specifier with Size"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Input Text is a"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Destination Type"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%hhd %hhi"),(0,i.kt)("td",{parentName:"tr",align:"left"},"very short decimal"),(0,i.kt)("td",{parentName:"tr",align:"left"},"char")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%hd %hi"),(0,i.kt)("td",{parentName:"tr",align:"left"},"short decimal"),(0,i.kt)("td",{parentName:"tr",align:"left"},"short")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%ld %li"),(0,i.kt)("td",{parentName:"tr",align:"left"},"long decimal"),(0,i.kt)("td",{parentName:"tr",align:"left"},"long")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%lld %lli"),(0,i.kt)("td",{parentName:"tr",align:"left"},"very long decimal"),(0,i.kt)("td",{parentName:"tr",align:"left"},"long long")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%lf %le %lg %la"),(0,i.kt)("td",{parentName:"tr",align:"left"},"floating-point"),(0,i.kt)("td",{parentName:"tr",align:"left"},"double")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%Lf %Le %Lg %La"),(0,i.kt)("td",{parentName:"tr",align:"left"},"floating-point"),(0,i.kt)("td",{parentName:"tr",align:"left"},"long double")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%hhu %hho %hhx"),(0,i.kt)("td",{parentName:"tr",align:"left"},"unsigned very short decimal"),(0,i.kt)("td",{parentName:"tr",align:"left"},"unsigned char")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%hu %ho %hx"),(0,i.kt)("td",{parentName:"tr",align:"left"},"unsigned short decimal"),(0,i.kt)("td",{parentName:"tr",align:"left"},"unsigned short")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%lu %lo %lx"),(0,i.kt)("td",{parentName:"tr",align:"left"},"unsigned long decimal"),(0,i.kt)("td",{parentName:"tr",align:"left"},"unsigned long")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%llu %llo %llx"),(0,i.kt)("td",{parentName:"tr",align:"left"},"unsigned very long decimal"),(0,i.kt)("td",{parentName:"tr",align:"left"},"unsigned long long")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%hhn"),(0,i.kt)("td",{parentName:"tr",align:"left"},"character string"),(0,i.kt)("td",{parentName:"tr",align:"left"},"char")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%hn"),(0,i.kt)("td",{parentName:"tr",align:"left"},"character string"),(0,i.kt)("td",{parentName:"tr",align:"left"},"short")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%ln"),(0,i.kt)("td",{parentName:"tr",align:"left"},"character string"),(0,i.kt)("td",{parentName:"tr",align:"left"},"long")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%lln"),(0,i.kt)("td",{parentName:"tr",align:"left"},"character string"),(0,i.kt)("td",{parentName:"tr",align:"left"},"long long")))),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Problems with %c")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"scanf()")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"fscanf()")," only extract the characters they need from the buffer, but problems arise with ",(0,i.kt)("inlineCode",{parentName:"p"},"%c")," conversions.  Consider the following program.  On reading an integer value, ",(0,i.kt)("inlineCode",{parentName:"p"},"scanf()")," leaves the newline character (",(0,i.kt)("inlineCode",{parentName:"p"},"'\\n'"),")in the input buffer.  Since the next call to ",(0,i.kt)("inlineCode",{parentName:"p"},"scanf()")," starts with a ",(0,i.kt)("inlineCode",{parentName:"p"},"%c")," specifier, ",(0,i.kt)("inlineCode",{parentName:"p"},"scanf()")," treats the unprocessed ",(0,i.kt)("inlineCode",{parentName:"p"},"'\\n'")," as the input character.  As a result, this program never collects the tax status input from the input buffer."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'/* scanf with %c Specification\n* scanf_c.c\n*/\n\n#include <stdio.h>\n\nint main(void)\n{\n        int items;\n        char status; // tax status g or p\n\n        printf("Number of items : ");\n        scanf("%d", &items);\n\n        printf("Status : ");\n        scanf("%c", &status);   // ERROR: assigns \\n to variable \'status\'\n                                //        and will not pause for user input\n\n        printf("%d items (%c)\\n", items, status); \n        \n        return 0;\n}\n')),(0,i.kt)("p",null,"The above program produces the following output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Number of items : 25\nStatus : 25 items (\n)\n")),(0,i.kt)("blockquote",null,(0,i.kt)("u",null,"Note"),(0,i.kt)("br",null),"Notice how the newline character (`'\\n'`) (which was assigned to the tax **status** variable) places the closing parenthesis on a newline."),(0,i.kt)("p",null,"There are different ways to handle unprocessed ",(0,i.kt)("inlineCode",{parentName:"p"},"'\\n'")," characters.  Some are listed in the ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"code snippets"))," below."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"Helpful Hint!"),(0,i.kt)("br",null),"\nA ",(0,i.kt)("strong",{parentName:"p"},"space character")," ",(0,i.kt)("em",{parentName:"p"},"before")," a conversion specifier forces the skipping of ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"all leading whitespace"))," before the next conversion.  "),(0,i.kt)("p",{parentName:"blockquote"},'For example, " %c" directs ',(0,i.kt)("inlineCode",{parentName:"p"},"scanf()")," to skip any whitespace characters before attempting to read the next non-whitespace character. ")),(0,i.kt)("p",null,"Method-1:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'scanf("%d", &items);\nscanf("%c%c", &junk, &status); // store one character in junk first\n')),(0,i.kt)("p",null,"Method-2:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'scanf("%d", &items);\nscanf("%*c%c", &status);       // discard(ignore) one character first\n')),(0,i.kt)("p",null,"Method-3:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'scanf("%d", &items);\nscanf(" %c", &status);         // discard(ignore) all whitespace first\n')),(0,i.kt)("p",null,"Method-4:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'scanf("%d%*c", &items);        // discard(ignore) newline (\'\\n\')\nscanf("%c", &status);\n')),(0,i.kt)("p",null,"Method-5:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'scanf("%d", &items);\nclear();                       // call a custom function to clear the buffer\nscanf("%c", &status);\n')),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},'"%*c%c"')," discards/ignores ",(0,i.kt)("strong",{parentName:"p"},"one")," character and accepts the next.",(0,i.kt)("br",null),"\n",(0,i.kt)("inlineCode",{parentName:"p"},'" %c"')," discards/ignores ",(0,i.kt)("strong",{parentName:"p"},"all")," whitespace characters before the next non-whitespace character."),(0,i.kt)("p",null,"One corrected version of the above program is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'// scanf with %c Specification\n// scanf_cc.c\n\n#include <stdio.h>\n\nint main(void)\n{\n        int items;\n        char status; // tax status g or p\n\n        printf("Number of items : ");\n        scanf("%d", &items);\n\n        printf("Status : ");\n        scanf(" %c", &status);   // note the space \n\n        printf("%d items (%c)\\n", items, status); \n\n        return 0;\n}\n')),(0,i.kt)("h3",{id:"unformatted-input"},"Unformatted Input"),(0,i.kt)("p",null,"The library functions for processing unformatted input are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"getchar()")," - character by character input from standard input (see Input Functions)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"fgetc()")," - character by character input from file (see Input Functions)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"gets_s()")," - line by line input from standard input (not universally implemented)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"fgets()")," - line by line input from file")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"gets_s (Optional)"))),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"gets_s()")," function..."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"accepts an empty string"),(0,i.kt)("li",{parentName:"ul"},"assumes no more than the specified number of characters"),(0,i.kt)("li",{parentName:"ul"},"reads the '\\n' as the delimiter"),(0,i.kt)("li",{parentName:"ul"},"replaces the delimiter with the null terminator")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"gets_s()")," takes two arguments.  Its prototype is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"char *gets_s(char *address, int n);\n")),(0,i.kt)("p",null,"The first parameter receives the address of the string to be filled.  The second parameter receives the maximum number of characters that can be stored including the null terminator byte.  On success, this function returns the address of the filled string:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'// Read and Display Lines\n// gets_s.c\n\n#include <stdio.h>\n\nint main(void)\n{\n        char first_name[21]; \n        char last_name[21]; \n\n        printf("First Name : ");\n        gets_s(first_name, 21);\n\n        printf("Last Name  : "); \n        gets_s(last_name, 21);\n\n        puts(first_name);\n        puts(last_name);\n\n        return 0;\n}\n')),(0,i.kt)("p",null,"The above program produces the following output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"First Name : Arnold\nLast Name  : Schwartzenegger \nArnold\nSchwartzenegger\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"IMPORTANT"),(0,i.kt)("br",null),"\nThe behaviour of ",(0,i.kt)("inlineCode",{parentName:"p"},"gets_s()")," is ",(0,i.kt)("strong",{parentName:"p"},"undefined")," if the user inputs a line ",(0,i.kt)("strong",{parentName:"p"},"longer")," than the allocated string.  On a Windows platform, this function ",(0,i.kt)("strong",{parentName:"p"},"crashes"),".",(0,i.kt)("br",null),"\nThe standard recommends use of ",(0,i.kt)("inlineCode",{parentName:"p"},"fgets()")," instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"gets_s()"),".")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"fgets")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"fgets()")," function..."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"reads a stream of bytes from the specified file"),(0,i.kt)("li",{parentName:"ul"},"accepts an empty string"),(0,i.kt)("li",{parentName:"ul"},"accepts no more than the specified number of characters"),(0,i.kt)("li",{parentName:"ul"},"reads until the ",(0,i.kt)("inlineCode",{parentName:"li"},"'\\n'")," delimiter"),(0,i.kt)("li",{parentName:"ul"},"includes the ",(0,i.kt)("inlineCode",{parentName:"li"},"'\\n'")," delimiter in the character string"),(0,i.kt)("li",{parentName:"ul"},"does not discard the ",(0,i.kt)("inlineCode",{parentName:"li"},"'\\n'")," delimiter"),(0,i.kt)("li",{parentName:"ul"},"adds the null terminator byte to the character string")),(0,i.kt)("p",null,"The prototype for this function is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"char* fgets(char str[], int max, FILE *fp);\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"str")," receives the address of the string to be filled.",(0,i.kt)("br",null),"\n",(0,i.kt)("inlineCode",{parentName:"p"},"max")," receives the maximum number of bytes in ",(0,i.kt)("inlineCode",{parentName:"p"},"str")," including space for the null terminator byte.",(0,i.kt)("br",null),"\n",(0,i.kt)("inlineCode",{parentName:"p"},"fp")," receives the address of the ",(0,i.kt)("inlineCode",{parentName:"p"},"FILE")," object.  "),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"fgets()")," appends the null terminator byte to the stored string."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"fgets()")," ",(0,i.kt)("em",{parentName:"p"},"returns")," the ",(0,i.kt)("strong",{parentName:"p"},"address")," of ",(0,i.kt)("inlineCode",{parentName:"p"},"str")," if successful, otherwise, ",(0,i.kt)("inlineCode",{parentName:"p"},"NULL")," in the event of an end of file or read error."),(0,i.kt)("h2",{id:"output"},"Output"),(0,i.kt)("p",null,"The stdio library functions for processing output are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"printf()")," - output to standard output under format control"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"fprintf()")," - output to a file under format control"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"putchar()")," - character by character output to standard output (",(0,i.kt)("a",{parentName:"li",href:"/D-Modularity/output-functions"},"see Output Functions"),")"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"fputc()")," - character by character output to a file (",(0,i.kt)("a",{parentName:"li",href:"/D-Modularity/output-functions"},"see Output Functions"),")"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"puts()")," - character string output to standard output (",(0,i.kt)("a",{parentName:"li",href:"/D-Modularity/output-functions"},"see Output Functions"),")"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"fputs()")," - character string output to a file (",(0,i.kt)("a",{parentName:"li",href:"/D-Modularity/output-functions"},"see Output Functions"),")")),(0,i.kt)("h3",{id:"formatted-output"},"Formatted Output"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"printf(...)")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"fprintf(...)")," functions report the value of the variable(s) or expression(s) in the argument list to the standard output device or the specified file respectively.  Their prototypes take the form:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"int printf(const char *format, ...);\nint fprintf(FILE *, const char *format, ...);\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"format")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"format")," is a string literal containing conversion specifiers and any characters to be output directly.  Each conversion specifier begins with a ",(0,i.kt)("inlineCode",{parentName:"p"},"%")," symbol and identifies the type of the source variable.  The order of the specifiers matches the order of the values received. "),(0,i.kt)("h3",{id:"conversion-specifiers"},"Conversion Specifiers"),(0,i.kt)("p",null,"The conversion specifiers include: "),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"left"},"Specifier"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Output Text is a"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Use with Type"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%c"),(0,i.kt)("td",{parentName:"tr",align:"left"},"character"),(0,i.kt)("td",{parentName:"tr",align:"left"},"char")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%d"),(0,i.kt)("td",{parentName:"tr",align:"left"},"signed decimal"),(0,i.kt)("td",{parentName:"tr",align:"left"},"int, short, long, long long")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%i"),(0,i.kt)("td",{parentName:"tr",align:"left"},"signed integer"),(0,i.kt)("td",{parentName:"tr",align:"left"},"int, short, long, long long")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%u"),(0,i.kt)("td",{parentName:"tr",align:"left"},"unsigned decimal"),(0,i.kt)("td",{parentName:"tr",align:"left"},"unsigned int, short, long, long long")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%o"),(0,i.kt)("td",{parentName:"tr",align:"left"},"unsigned octal"),(0,i.kt)("td",{parentName:"tr",align:"left"},"unsigned int, short, long, long long")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%x"),(0,i.kt)("td",{parentName:"tr",align:"left"},"unsigned hexadecimal"),(0,i.kt)("td",{parentName:"tr",align:"left"},"unsigned int, short, long, long long")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%X"),(0,i.kt)("td",{parentName:"tr",align:"left"},"unsigned hexadecimal (uppercase)"),(0,i.kt)("td",{parentName:"tr",align:"left"},"unsigned int, short, long, long long")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%n"),(0,i.kt)("td",{parentName:"tr",align:"left"},"--"),(0,i.kt)("td",{parentName:"tr",align:"left"},"int *")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%f"),(0,i.kt)("td",{parentName:"tr",align:"left"},"floating-point"),(0,i.kt)("td",{parentName:"tr",align:"left"},"float, double, long double")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%F"),(0,i.kt)("td",{parentName:"tr",align:"left"},"floating-point (uppercase)"),(0,i.kt)("td",{parentName:"tr",align:"left"},"float, double, long double")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%e"),(0,i.kt)("td",{parentName:"tr",align:"left"},"scientific floating-point"),(0,i.kt)("td",{parentName:"tr",align:"left"},"float, double, long double")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%E"),(0,i.kt)("td",{parentName:"tr",align:"left"},"scientific floating-point (uppercase)"),(0,i.kt)("td",{parentName:"tr",align:"left"},"float, double, long double")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%g"),(0,i.kt)("td",{parentName:"tr",align:"left"},"shortest floating-point"),(0,i.kt)("td",{parentName:"tr",align:"left"},"float, double, long double")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%G"),(0,i.kt)("td",{parentName:"tr",align:"left"},"shortest floating-point (uppercase)"),(0,i.kt)("td",{parentName:"tr",align:"left"},"float, double, long double")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%a"),(0,i.kt)("td",{parentName:"tr",align:"left"},"hexadecimal floating-point"),(0,i.kt)("td",{parentName:"tr",align:"left"},"float, double, long double")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%A"),(0,i.kt)("td",{parentName:"tr",align:"left"},"hexadecimal floating-point (uppercase)"),(0,i.kt)("td",{parentName:"tr",align:"left"},"float, double, long double")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%s"),(0,i.kt)("td",{parentName:"tr",align:"left"},"string of characters"),(0,i.kt)("td",{parentName:"tr",align:"left"},"char *")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%%"),(0,i.kt)("td",{parentName:"tr",align:"left"},"the character %"),(0,i.kt)("td",{parentName:"tr",align:"left"},"char *")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%p"),(0,i.kt)("td",{parentName:"tr",align:"left"},"address"),(0,i.kt)("td",{parentName:"tr",align:"left"},"--")))),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"%n")," does not output any characters but instead returns the number of characters processed so far. "),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"Scientific"))," (",(0,i.kt)("inlineCode",{parentName:"p"},"%e")," ",(0,i.kt)("inlineCode",{parentName:"p"},"%E"),") refers to output in mantissa/exponent form ",(0,i.kt)("inlineCode",{parentName:"p"},"d.dddEdd")," (for example, ",(0,i.kt)("inlineCode",{parentName:"p"},"0.123e3"),", which stands for ",(0,i.kt)("inlineCode",{parentName:"p"},"0.123 x 103")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"123.0"),"). "),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"General"))," (",(0,i.kt)("inlineCode",{parentName:"p"},"%g")," ",(0,i.kt)("inlineCode",{parentName:"p"},"%G"),") refers to output in the shortest form possible; decimal or mantissa/exponent.  (for example, ",(0,i.kt)("inlineCode",{parentName:"p"},"0.123e-5")," rather than ",(0,i.kt)("inlineCode",{parentName:"p"},"0.00000123")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"3.1")," rather than ",(0,i.kt)("inlineCode",{parentName:"p"},"0.31e1"),". "),(0,i.kt)("h3",{id:"conversion-control-1"},"Conversion Control"),(0,i.kt)("p",null,"We may insert control characters between the ",(0,i.kt)("inlineCode",{parentName:"p"},"%")," and the conversion character.  The general form of a conversion specification is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"% flags width . precision size conversion_character\n")),(0,i.kt)("p",null,"The five control characters are:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("em",{parentName:"strong"},"flags")),(0,i.kt)("br",null),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"prescribes left justification of the converted value in its field"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"0")," pads the field width with ",(0,i.kt)("strong",{parentName:"li"},"leading zeros")))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("em",{parentName:"strong"},"width"))," sets the minimum field width within which to format the value (overriding with a wider field only if necessary).  Pads the converted value on the left (or right, for left alignment).  The padding character used is either a ",(0,i.kt)("strong",{parentName:"li"},"space")," or ",(0,i.kt)("strong",{parentName:"li"},"0")," if the padding flag is on"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},".")," separates the field's width from the field's precision"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("em",{parentName:"strong"},"precision"))," sets the number of digits to be printed after the decimal point for ",(0,i.kt)("inlineCode",{parentName:"li"},"%f")," conversions and the minimum number of digits to be printed for an ",(0,i.kt)("strong",{parentName:"li"},"integer")," (adding leading zeros if necessary).  A value of ",(0,i.kt)("inlineCode",{parentName:"li"},"0")," suppresses the printing of the decimal point in a ",(0,i.kt)("inlineCode",{parentName:"li"},"%f")," conversion.  An ",(0,i.kt)("inlineCode",{parentName:"li"},"*")," instead of a number applies the value from the next argument in the argument list"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("em",{parentName:"strong"},"size")),"  identifies the ",(0,i.kt)("em",{parentName:"li"},"minimum")," size of the type being output")),(0,i.kt)("p",null,"The size specifiers covered in this course are listed below.  Others may be found ",(0,i.kt)("a",{parentName:"p",href:"http://www.cplusplus.com/reference/cstdio/printf/"},"on the web")),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"left"},"Specifier with Size"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Output Text is"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Use with Type"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%hhd %hhi"),(0,i.kt)("td",{parentName:"tr",align:"left"},"very short decimal"),(0,i.kt)("td",{parentName:"tr",align:"left"},"char")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%hd %hi"),(0,i.kt)("td",{parentName:"tr",align:"left"},"short decimal"),(0,i.kt)("td",{parentName:"tr",align:"left"},"short")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%ld %li"),(0,i.kt)("td",{parentName:"tr",align:"left"},"long decimal"),(0,i.kt)("td",{parentName:"tr",align:"left"},"long")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%lld %lli"),(0,i.kt)("td",{parentName:"tr",align:"left"},"very long decimal"),(0,i.kt)("td",{parentName:"tr",align:"left"},"long long")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%lf %lF %le %lE %lg %lG %la %lA"),(0,i.kt)("td",{parentName:"tr",align:"left"},"floating-point"),(0,i.kt)("td",{parentName:"tr",align:"left"},"double")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%Lf %LF %Le %LE %Lg %LG %La %LA"),(0,i.kt)("td",{parentName:"tr",align:"left"},"floating-point"),(0,i.kt)("td",{parentName:"tr",align:"left"},"long double")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%hhu %hho %hhx %hhX"),(0,i.kt)("td",{parentName:"tr",align:"left"},"unsigned very short decimal"),(0,i.kt)("td",{parentName:"tr",align:"left"},"unsigned char")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%hu %ho %hx %hhX"),(0,i.kt)("td",{parentName:"tr",align:"left"},"unsigned short decimal"),(0,i.kt)("td",{parentName:"tr",align:"left"},"unsigned short")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%lu %lo %lx %hhX"),(0,i.kt)("td",{parentName:"tr",align:"left"},"unsigned long decimal"),(0,i.kt)("td",{parentName:"tr",align:"left"},"unsigned long")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%llu %llo %llx %hhX"),(0,i.kt)("td",{parentName:"tr",align:"left"},"unsigned very long decimal"),(0,i.kt)("td",{parentName:"tr",align:"left"},"unsigned long long")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%hhn"),(0,i.kt)("td",{parentName:"tr",align:"left"},"character string"),(0,i.kt)("td",{parentName:"tr",align:"left"},"char")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%hn"),(0,i.kt)("td",{parentName:"tr",align:"left"},"character string"),(0,i.kt)("td",{parentName:"tr",align:"left"},"short")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%ln"),(0,i.kt)("td",{parentName:"tr",align:"left"},"character string"),(0,i.kt)("td",{parentName:"tr",align:"left"},"long")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"%lln"),(0,i.kt)("td",{parentName:"tr",align:"left"},"character string"),(0,i.kt)("td",{parentName:"tr",align:"left"},"long long")))),(0,i.kt)("h2",{id:"custom-input-optional"},"Custom Input (Optional)"),(0,i.kt)("h3",{id:"mismatching-line-input"},"Mismatching Line Input"),(0,i.kt)("p",null,"Managing line-oriented input helps in debugging.  Consider a set of input lines some of which contain incorrect input.  Ideally, a one-to-one correspondence should exist between the lines of input data and the lines read by the program.  Even if the user inputs a line incorrectly, subsequent correct input may still be acceptable.  In other words, incorrect input on one line should not cause incorrect reading of subsequent lines. "),(0,i.kt)("p",null,"Ideally, line by line input should:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"store characters only to a specified maximum"),(0,i.kt)("li",{parentName:"ul"},"accept an empty string"),(0,i.kt)("li",{parentName:"ul"},"read the '\\n' as the line delimiter"),(0,i.kt)("li",{parentName:"ul"},"discard the delimiting character along with any characters that overflow memory"),(0,i.kt)("li",{parentName:"ul"},"append the null terminator to the set of characters stored")),(0,i.kt)("p",null,"The following code meets all of these conditions:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"// Custom Line-Oriented Input\n// getline.c\n\n#include <stdio.h>\n\n// getline accepts a newline terminated\n// string s of up to max - 1 characters,\n// adds the null terminator and discards\n// the remaining characters in  the input\n// buffer including terminating character\n//\nchar *getline(char *s, int n)\n{\n        int i, c;\n\n        for (i = 0; i < n - 1 && (c =getchar()) != EOF && c != (int)'\\n'; i++)\n                s[i] = c;\n        s[i] = '\\0';\n\n        while (n > 1 && c != EOF && c != (int)'\\n')\n                c = getchar();\n        \n        return c != EOF ? s : NULL;\n}\n\nint main(void)\n{\n        char first_name[11]; \n        char last_name[11]; \n\n        printf(\"First Name : \");\n        getline(first_name, 11);\n\n        printf(\"Last Name  : \");\n        getline(last_name, 11);\n\n        puts(first_name);\n        puts(last_name);\n\n        return 0;\n}\n")),(0,i.kt)("p",null,"The above program produces the following output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"First Name : Arnold\nLast Name  : Schwartzenegger \nArnold\nSchwartzen\n")),(0,i.kt)("p",null,"This function, unlike ",(0,i.kt)("inlineCode",{parentName:"p"},"gets_s()")," has well-defined behavior if the number of characters entered exceeds the amount of memory available to store the string."),(0,i.kt)("h3",{id:"insufficient-memory-optional"},"Insufficient Memory (Optional)"),(0,i.kt)("p",null,"Consider the file named ",(0,i.kt)("inlineCode",{parentName:"p"},"spring.dat"),", the contents of which are listed below.  Each record in this file contains three fields: the first field holds the ",(0,i.kt)("strong",{parentName:"p"},"quantity"),", the second field holds a C string describing the item (",(0,i.kt)("strong",{parentName:"p"},"label"),") and the third field holds the unit ",(0,i.kt)("strong",{parentName:"p"},"price")," of the item.  The field delimiter is the semi-colon (",(0,i.kt)("inlineCode",{parentName:"p"},";"),") character: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"2;Light Jacket;95.89\n3;Long Pants;67.89\n2;Large Duster;45.98\n")),(0,i.kt)("p",null,"The following program reads each record from the file and displays the fields in a tabular format:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'// Tabular Data\n// table.c\n\n#include <stdio.h>\n\nint main(void)\n{\n        FILE *fp = NULL;\n        char label [14];\n        int n;\n        double price;\n\n        fp = fopen("spring.txt","r");\n        if (fp != NULL)\n        {\n                printf("    Spring Items\\n"\n                       "    ============\\n\\n"\n                       "No Description  Price\\n"\n                       "---------------------\\n"); \n                \n                while (fscanf(fp, "%d;%13[^;];%lf%*c", &n, label, &price) == 3)\n                        printf("%2d %-13s%5.2lf\\n", n, label, price);\n                \n                fclose(fp);\n        }\n\n        return 0;\n}\n')),(0,i.kt)("p",null,"The above program produces the following output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"    Spring Items\n    ============\n\nNo Description  Price\n---------------------\n 2 Light Jacket 95.89\n 3 Long Pants   67.89\n 2 Large Duster 45.98\n")),(0,i.kt)("blockquote",null,(0,i.kt)("u",null,"Note"),(0,i.kt)("br",null),"Notice how the field delimiters have been embedded within `fscanf()`'s format string."),(0,i.kt)("h3",{id:"safe-coding"},"Safe Coding"),(0,i.kt)("p",null,"The above program executes successfully only if the descriptive strings in the file do not contain ",(0,i.kt)("strong",{parentName:"p"},"more than 13 characters"),".  The data in a different file that contains longer labels will not fit into the space allocated by the program. "),(0,i.kt)("p",null,"To process any file and safeguard against ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"memory overflow")),", we can modify the program to ",(0,i.kt)("strong",{parentName:"p"},"skip the extra characters")," in the description field that exceeds the memory allocated for the ",(0,i.kt)("inlineCode",{parentName:"p"},"label")," C string character array variable.  We do so by reading each record in two separate statements:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'// Insufficient Memory\n// table_plus.c\n\n#include <stdio.h>\n\nint main(void)\n{\n        FILE *fp = NULL;\n        char label [14];\n        int n;\n        double price;\n        char c;\n\n        fp = fopen("spring.txt","r");\n\n        if (fp != NULL)\n        {\n                printf("    Spring Items\\n"\n                       "    ============\\n\\n"\n                       "No Description  Price\\n"\n                       "---------------------\\n");\n                \n                while (fscanf(fp,"%d;%13[^;]%c", &n, label, &c) == 3)\n                {\n                        if (c == \';\')\n                                fscanf(fp,"%lf\\n", &price);\n                        else\n                                fscanf(fp, "%*[^;];%lf%*c", &price); \n                        \n                        printf("%2d %-13s%5.2lf\\n", n, label, price);\n                }\n\n                fclose(fp);\n        }\n\n        return 0;\n}\n')),(0,i.kt)("p",null,"The above program produces the following output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"     Spring Items\n     ============\n\nNo Description  Price\n---------------------\n 2 Light Jacket 95.89\n 3 Long Pants   67.89\n 2 Large Duster 45.98\n")),(0,i.kt)("p",null,"The first statement reads the first two fields stopping at the second delimiter or once memory is full, whichever comes first.  If the statement has encountered the second delimiter, the second statement reads the price; if not, the alternate version of the second statement skips the remaining characters in the field and the second delimiter and only then reads the price. "),(0,i.kt)("p",null,"The program stops reading altogether as soon as it encounters a record with other than 3 input values - the quantity, the descriptive string and the second delimiter."))}c.isMDXComponent=!0}}]);