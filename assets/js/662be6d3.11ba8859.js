"use strict";(self.webpackChunkipc144=self.webpackChunkipc144||[]).push([[220],{3905:function(e,n,t){t.d(n,{Zo:function(){return d},kt:function(){return f}});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var c=r.createContext({}),s=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},d=function(e){var n=s(e.components);return r.createElement(c.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},u=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,c=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),u=s(t),f=a,h=u["".concat(c,".").concat(f)]||u[f]||p[f]||i;return t?r.createElement(h,o(o({ref:n},d),{},{components:t})):r.createElement(h,o({ref:n},d))}));function f(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,o=new Array(i);o[0]=u;var l={};for(var c in n)hasOwnProperty.call(n,c)&&(l[c]=n[c]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var s=2;s<i;s++)o[s]=t[s];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}u.displayName="MDXCreateElement"},8148:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return l},contentTitle:function(){return c},metadata:function(){return s},toc:function(){return d},default:function(){return u}});var r=t(7462),a=t(3366),i=(t(7294),t(3905)),o=["components"],l={sidebar_position:2},c="Records and Files",s={unversionedId:"E-Secondary-Storage/records-and-files",id:"E-Secondary-Storage/records-and-files",isDocsHomePage:!1,title:"Records and Files",description:"Learning Outcomes",source:"@site/docs/E-Secondary-Storage/records-and-files.md",sourceDirName:"E-Secondary-Storage",slug:"/E-Secondary-Storage/records-and-files",permalink:"/E-Secondary-Storage/records-and-files",editUrl:"https://github.com/Seneca-ICTOER/IPC144/tree/main/docs/E-Secondary-Storage/records-and-files.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"courseNotesSidebar",previous:{title:"Text Files",permalink:"/E-Secondary-Storage/text-files"},next:{title:"Character Strings (C string)",permalink:"/F-Refinements/character-strings"}},d=[{value:"Learning Outcomes",id:"learning-outcomes",children:[],level:2},{value:"Introduction",id:"introduction",children:[],level:2},{value:"Records",id:"records",children:[],level:2},{value:"Fields",id:"fields",children:[],level:2},{value:"Tables",id:"tables",children:[],level:2}],p={toc:d};function u(e){var n=e.components,t=(0,a.Z)(e,o);return(0,i.kt)("wrapper",(0,r.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"records-and-files"},"Records and Files"),(0,i.kt)("h2",{id:"learning-outcomes"},"Learning Outcomes"),(0,i.kt)("p",null,"After reading this section, you will be able to:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Stream data using standard library functions to access persistent text")),(0,i.kt)("h2",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,"Persistent data hierarchies typically consist of databases composed of files, which consist of records, which consist of fields, which consist of bytes, which are stored in bits.  In files that hold a tabular structure, each record contains the same number of fields. "),(0,i.kt)("p",null,"This chapter describes how to identify records and fields in a text file and how to retrieve tabular data."),(0,i.kt)("h2",{id:"records"},"Records"),(0,i.kt)("p",null,"A ",(0,i.kt)("strong",{parentName:"p"},"record")," occupies a single line in a text file and holds all of the data associated with one chunk of information.  The record is a sequence of characters that ends with a record delimiter.  The typical record delimiter is the newline character (",(0,i.kt)("inlineCode",{parentName:"p"},"\\n"),"). "),(0,i.kt)("p",null,"~",(0,i.kt)("a",{parentName:"p",href:"https://ict.senecacollege.ca//~ipc144/pages/images/records.png"})),(0,i.kt)("p",null,"Consider a text file named ",(0,i.kt)("inlineCode",{parentName:"p"},"produce.txt")," containing information about items of produce in a grocery store.  Each record consists of the ",(0,i.kt)("strong",{parentName:"p"},"sku")," for a product and its ",(0,i.kt)("strong",{parentName:"p"},"unit price"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"4664 1.49\n4419 1.29\n4011 0.59 \n")),(0,i.kt)("p",null,"To determine the number of records in this file, we count the number of newline (",(0,i.kt)("inlineCode",{parentName:"p"},"'\\n'"),") characters: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'// Number of Records\n// records.c\n\n#include <stdio.h>\n\nint main(void)\n{\n        FILE *fp = NULL;\n        int c, nrecs;\n\n        fp = fopen("produce.txt", "r");\n\n        if (fp != NULL)\n        {\n                nrecs = 0;\n                do {\n                        c = fgetc(fp);\n                        if (c != EOF)\n                        {\n                                if ((char)c == \'\\n\') \n                                        nrecs++;\n                        }\n                } while (feof(fp) == 0);\n\n                printf("%d records on file\\n", nrecs);\n                fclose(fp);\n        }\n\n        return 0;\n}\n')),(0,i.kt)("p",null,"The above program produces the following output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"3 records on file\n")),(0,i.kt)("blockquote",null,(0,i.kt)("u",null,"Note"),(0,i.kt)("br",null),"Since this program determines the number of records in the file by counting the newline characters, to report the correct number of records, the last record in the file must end with a newline character.  If the last record does not end with a newline character, the count will be off by one."),(0,i.kt)("h2",{id:"fields"},"Fields"),(0,i.kt)("p",null,"A ",(0,i.kt)("strong",{parentName:"p"},"field")," holds one element of information within a single record.  We separate adjacent fields within a record by a ",(0,i.kt)("strong",{parentName:"p"},"field delimiter"),". "),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://ict.senecacollege.ca//~ipc144/pages/images/fields.png",alt:null})),(0,i.kt)("p",null,"Consider the file named ",(0,i.kt)("inlineCode",{parentName:"p"},"produce.txt")," (see above).  Each record contains two fields: the first field holds the ",(0,i.kt)("strong",{parentName:"p"},"sku")," and the second field holds the ",(0,i.kt)("strong",{parentName:"p"},"unit price"),".  The field delimiter is a blank character. "),(0,i.kt)("p",null,"The following program reads the fields of each record in the file and displays their contents:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'// Record and Fields\n// recordFields.c\n\n#include <stdio.h>\n\nint main(void)\n{\n        FILE *fp = NULL;\n        int sku;\n        double price;\n\n        fp = fopen("produce.txt", "r");\n\n        if (fp != NULL) \n        {\n                printf(" Produce Items\\n"\n                    " =============\\n\\n"\n                    "sku       Price\\n"\n                    "---------------\\n");\n\n                while (fscanf(fp,"%d%lf\\n", &sku, &price) == 2) \n                        printf("%4d %10.2lf\\n", sku, price); \n                \n                fclose(fp);\n        }\n        \n        return 0;\n}\n')),(0,i.kt)("p",null,"The above program produces the following output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"}," Produce Items\n =============\n\nsku       Price\n---------------\n4664       1.49\n4419       1.29\n4011       0.59 \n")),(0,i.kt)("h2",{id:"tables"},"Tables"),(0,i.kt)("p",null,"A ",(0,i.kt)("strong",{parentName:"p"},"table")," is a set of records in which each record contains the same number of fields."),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://ict.senecacollege.ca//~ipc144/pages/images/tables.png",alt:null})),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Warning",(0,i.kt)("br",null),"\nIf one of the fields in a record is a character field, the blank character might not be suitable as a field delimiter and we select a special character for that purpose. ")),(0,i.kt)("p",null,"Consider the file named ",(0,i.kt)("inlineCode",{parentName:"p"},"sale.txt")," (its contents are listed below).  Each record in this file contains three fields: "),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"sku")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"price status")," (a single character where a blank character represents the regular price and ",(0,i.kt)("inlineCode",{parentName:"li"},"*")," represents a sale) "),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"unit price"))),(0,i.kt)("p",null,"The field delimiter is the semi-colon character (",(0,i.kt)("inlineCode",{parentName:"p"},";"),"): "),(0,i.kt)("p",null,"The following program reads each record from the file and displays the fields in a tabular format:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'// Tabular Data\n// table.c\n\n#include <stdio.h>\n\nint main(void)\n{\n        FILE *fp = NULL;\n        int sku;\n        char status;\n        double price;\n\n        fp = fopen("sale.txt","r");\n\n        if (fp != NULL)\n        {\n                printf(" Produce Items\\n"\n                    " =============\\n\\n"\n                    "sku  Sale  Price\\n"\n                    "----------------\\n");\n                \n                while (fscanf(fp, "%d;%c;%lf", &sku, &status, &price) == 3)\n                        printf("%4d %c %8.2lf\\n", sku, status, price);\n                \n                fclose(fp);\n        }\n   \n        return 0;\n}\n')),(0,i.kt)("p",null,"The above program produces the following output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"}," Produce Items\n =============\n\nsku  Sale  Price\n----------------\n4664 *      1.49\n4419 *      1.29\n4011        0.59 \n")),(0,i.kt)("blockquote",null,(0,i.kt)("u",null,"Note"),(0,i.kt)("br",null),"We have included the field delimiters within `fscanf()`'s format string and these delimiter characters are discarded and not assigned to any variables."))}u.isMDXComponent=!0}}]);